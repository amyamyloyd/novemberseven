---
alwaysApply: false
---
fileType: python
name: python.mdc
description: Enforces strict Python backend standards for logging, structure, testing, and database behavior
---
You are an expert in Python 3.11 backend development using FastAPI, SQLite, pandas, and LangChain. Your goal is to enforce precise, reproducible code patterns based on strict internal standards. You are building for clarity, reliability, and maintainability.

## ðŸ Python Code Standards

### âœ… Virtual Environment Enforcement
- All code **must be executed inside the active virtual environment (`venv/`)**.
- Never use system Python or spawn scripts in a non-venv shell.
- Use `venv/bin/python`, `venv/bin/pytest`, and `venv/bin/uvicorn` for execution.
- Never spawn new terminals â€” re-use the active terminal session.

---

### ðŸ“¦ Import Order and Structure

Organize imports in this order, grouped and separated by one newline:
```python
# Standard library
import os
import json
import logging
from typing import List, Dict, Optional, Any

# Third-party libraries
import pandas as pd
from fastapi import HTTPException

# Local application modules
from .db_manager import get_database_connection
from .data_processor import process_data
````

* One import per line â€” no wildcards (`from x import *`)
* All FastAPI imports must come from `fastapi` directly
* Prefer absolute imports unless inside tight module clusters

---

### ðŸ“‹ Docstring Format

All public functions must have docstrings following this structure:

```python
def example_function(arg1: str) -> int:
    """
    Brief one-line summary of the function.

    Args:
        arg1 (str): Description of argument

    Returns:
        int: Description of return value

    Raises:
        ValueError: On invalid input

    Example:
        result = example_function("abc")
    """
```

* Required sections: `Args`, `Returns`, `Raises`, `Example`
* Must match actual function signature and error behavior
* Private/internal functions (`_func`) may omit docstrings

---

### ðŸ§± Logging Standards

* Always configure at module level:

```python
logger = logging.getLogger(__name__)
```

* Log major steps and all exceptions:

```python
logger.info(f"Processing file {file_path}")
logger.error(f"Failed due to {str(e)}")
```

* No print statements for logging
* All raised exceptions must be logged first

---

### ðŸ› ï¸ SQLite Access

* SQLite is the default and only backend unless otherwise stated
* Do not modify database engine, `.env`, or ports
* All access should flow through abstraction layers:

```python
from .db_manager import get_database_connection
```

* Use SQLite with `pandas` and `FastAPI` for data operations
* Never mix raw SQL and ORM unless explicitly requested

---

### ðŸš« Error Handling Rules

* Do not use `try/except` to silently ignore errors
* Raise structured exceptions:

```python
raise ValueError("Descriptive error")
raise FileNotFoundError("Excel file not found")
raise HTTPException(status_code=400, detail="Missing parameter")
```

* Always log before raising
* Use `guard clauses` early in functions:

```python
if not os.path.exists(file_path):
    logger.error(f"File not found: {file_path}")
    raise FileNotFoundError(...)
```

---

### ðŸ“ Sample Pattern â€” Enforced for File Processors

```python
import os
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)

def process_file(file_path: str) -> Dict[str, Any]:
    """
    Process a file and extract relevant data

    Args:
        file_path (str): Path to the file to process

    Returns:
        Dict[str, Any]: Processed data structure

    Raises:
        ValueError: If file is invalid or corrupted
        FileNotFoundError: If file path doesn't exist

    Example:
        data = process_file("data/input.txt")
    """
    if not os.path.exists(file_path):
        logger.error(f"File not found: {file_path}")
        raise FileNotFoundError(f"File not found: {file_path}")

    try:
        # Process file logic here
        logger.info(f"Successfully processed file: {file_path}")
        return {"status": "success", "file": file_path}
    except Exception as e:
        logger.error(f"Failed to process file {file_path}: {str(e)}")
        raise ValueError(f"File processing failed: {str(e)}")
```

---

### ðŸ§ª Testing Rules (Python)

* Use `pytest`
* Place tests in `/tests/` folder, mirroring app structure
* Use `TestClient` for FastAPI endpoint tests
* Mock filesystem, external APIs, LLMs
* Target 90%+ coverage for services and endpoints
